ExerciseAngina = factor(ExerciseAngina),
ST_Slope       = factor(ST_Slope)
) %>%
add_heart_features() %>%
mutate(
age_decade     = factor(age_decade),
high_bp_flag   = factor(high_bp_flag),
high_chol_flag = factor(high_chol_flag)
)
## ---- 4) train / test 分层抽样 ----
idx <- caret::createDataPartition(heart$HeartDisease,
p = p_train, list = FALSE)
train_dat <- heart[idx, ]
test_dat  <- heart[-idx, ]
x_train <- train_dat %>% select(-HeartDisease)
x_test  <- test_dat  %>% select(-HeartDisease)
y_train <- train_dat$HeartDisease
y_test  <- test_dat$HeartDisease
## ---- 5) 缺失值处理 & 记录 preproc 信息 ----
num_cols <- names(x_train)[sapply(x_train, is.numeric)]
fac_cols <- names(x_train)[sapply(x_train, is.factor)]
# 数值列：用 train 中位数填补
num_medians <- vapply(num_cols, function(cn) {
median(x_train[[cn]], na.rm = TRUE)
}, numeric(1))
for (cn in num_cols) {
med <- num_medians[[cn]]
x_train[[cn]][is.na(x_train[[cn]])] <- med
x_test[[cn]][is.na(x_test[[cn]])]   <- med
}
# 因子列：NA -> "Unknown"，并对齐 levels
fac_levels <- list()
for (cn in fac_cols) {
x_train[[cn]] <- forcats::fct_explicit_na(x_train[[cn]], na_level = "Unknown")
x_test[[cn]]  <- forcats::fct_explicit_na(x_test[[cn]],  na_level = "Unknown")
x_test[[cn]]  <- factor(x_test[[cn]], levels = levels(x_train[[cn]]))
fac_levels[[cn]] <- levels(x_train[[cn]])
}
# 近零方差特征删除，记录被删掉的列名
nzv_idx <- nearZeroVar(x_train)
if (length(nzv_idx) > 0) {
nzv_cols <- colnames(x_train)[nzv_idx]
x_train  <- x_train[, -nzv_idx, drop = FALSE]
x_test   <- x_test[,  -nzv_idx, drop = FALSE]
} else {
nzv_cols <- character(0)
}
train_dat_rf  <- data.frame(HeartDisease = y_train, x_train)
train_dat_glm <- train_dat_rf
positive_level <- "Presence"
negative_level <- setdiff(levels(y_train), positive_level)
preproc <- list(
num_cols       = num_cols,
num_medians    = num_medians,
fac_cols       = fac_cols,
fac_levels     = fac_levels,
nzv_cols       = nzv_cols,
positive_level = positive_level,
negative_level = negative_level
)
list(
heart_raw      = heart_raw,
heart_clean    = heart,
x_train        = x_train,
x_test         = x_test,
y_train        = y_train,
y_test         = y_test,
train_dat_rf   = train_dat_rf,
train_dat_glm  = train_dat_glm,
preproc        = preproc
)
}
############################################################
## 3. 统一二分类评估函数：Accuracy / F1 / AUROC / AUPRC
############################################################
evaluate_binary <- function(y_true, prob_pos, positive_level = "Presence") {
y_bin <- ifelse(y_true == positive_level, 1, 0)
# ROC / AUROC
roc_obj <- pROC::roc(response = y_bin, predictor = prob_pos, quiet = TRUE)
auroc   <- as.numeric(pROC::auc(roc_obj))
# PR / AUPRC
pr_obj <- PRROC::pr.curve(
scores.class0 = prob_pos[y_bin == 1],  # 正类
scores.class1 = prob_pos[y_bin == 0],  # 负类
curve = TRUE
)
auprc <- pr_obj$auc.integral
pr_df <- as.data.frame(pr_obj$curve)
colnames(pr_df) <- c("Recall","Precision","Threshold")
# PR 曲线上的点计算 F1，选 F1 最大的阈值
pr_df$F1 <- 2 * pr_df$Precision * pr_df$Recall /
(pr_df$Precision + pr_df$Recall)
best_row <- pr_df[which.max(pr_df$F1), ]
best_thr <- best_row$Threshold
negative_level <- setdiff(levels(y_true), positive_level)
pred_class <- factor(
ifelse(prob_pos >= best_thr, positive_level, negative_level),
levels = levels(y_true)
)
cm <- caret::confusionMatrix(pred_class, y_true, positive = positive_level)
accuracy <- cm$overall["Accuracy"]
precision <- cm$byClass["Pos Pred Value"]
recall    <- cm$byClass["Sensitivity"]
F1        <- 2 * precision * recall / (precision + recall)
list(
auroc          = auroc,
auprc          = auprc,
accuracy       = as.numeric(accuracy),
F1             = as.numeric(F1),
best_threshold = best_thr,
roc_obj        = roc_obj,
pr_df          = pr_df,
cm             = cm,
pred_class     = pred_class
)
}
############################################################
## 4. 训练所有模型：Logistic + Full RF + Top-10 RF
############################################################
fit_heart_models <- function(dp, seed = 215) {
set.seed(seed)
x_train        <- dp$x_train
x_test         <- dp$x_test
y_train        <- dp$y_train
y_test         <- dp$y_test
train_dat_rf   <- dp$train_dat_rf
train_dat_glm  <- dp$train_dat_glm
preproc        <- dp$preproc
positive_level <- preproc$positive_level
## ---- 4.1 Logistic baseline ----
glm_fit <- glm(
HeartDisease ~ .,
data   = train_dat_glm,
family = binomial()
)
prob_pos_glm <- predict(glm_fit, newdata = x_test, type = "response")
ev_glm <- evaluate_binary(y_test, prob_pos_glm, positive_level)
## ---- 4.2 RF 调参（基于 OOB-AUROC） ----
class_counts  <- table(y_train)
class_weights <- as.numeric(mean(class_counts) / class_counts)
names(class_weights) <- names(class_counts)
p <- ncol(x_train)
mtry_candidates      <- unique(pmax(1, c(floor(sqrt(p)), floor(p/3), floor(p/2))))
min_node_candidates  <- c(5, 10, 20)
splitrule_candidates <- c("gini", "extratrees")
tune_grid <- expand.grid(
mtry          = mtry_candidates,
min.node.size = min_node_candidates,
splitrule     = splitrule_candidates
)
tune_grid$oob_auc <- NA_real_
set.seed(seed)
for (i in seq_len(nrow(tune_grid))) {
cat("Fitting RF", i, "of", nrow(tune_grid), "\n")
fit_tmp <- ranger(
dependent.variable.name = "HeartDisease",
data      = train_dat_rf,
num.trees = 400,
mtry      = tune_grid$mtry[i],
min.node.size = tune_grid$min.node.size[i],
splitrule = tune_grid$splitrule[i],
importance = "impurity",
probability = TRUE,
respect.unordered.factors = "order",
class.weights = class_weights
)
oob_prob <- fit_tmp$predictions[, positive_level]
y_oob    <- y_train
roc_oob <- pROC::roc(
response  = ifelse(y_oob == positive_level, 1, 0),
predictor = oob_prob,
quiet     = TRUE
)
tune_grid$oob_auc[i] <- as.numeric(pROC::auc(roc_oob))
}
best_par <- tune_grid[which.max(tune_grid$oob_auc), ]
print(best_par)
## ---- 4.3 最终 RF（全特征） ----
set.seed(seed)
rf_full <- ranger(
dependent.variable.name = "HeartDisease",
data      = train_dat_rf,
num.trees = 1000,
mtry      = best_par$mtry,
min.node.size = best_par$min.node.size,
splitrule = best_par$splitrule,
importance = "permutation",
probability = TRUE,
respect.unordered.factors = "order",
class.weights = class_weights
)
rf_pred_full  <- predict(rf_full, data = x_test)
prob_mat_full <- rf_pred_full$predictions
prob_pos_full <- prob_mat_full[, positive_level]
ev_full <- evaluate_binary(y_test, prob_pos_full, positive_level)
## ---- 4.4 Top-10 特征 RF ----
imp_full <- vip::vi(rf_full) %>%
arrange(desc(Importance))
print(imp_full)
top_feats <- imp_full$Variable[1:min(10, nrow(imp_full))]
message("Top-10 特征: ", paste(top_feats, collapse = ", "))
x_train_top <- x_train[, top_feats, drop = FALSE]
x_test_top  <- x_test[,  top_feats,  drop = FALSE]
train_dat_top <- data.frame(HeartDisease = y_train, x_train_top)
set.seed(seed)
rf_top <- ranger(
dependent.variable.name = "HeartDisease",
data      = train_dat_top,
num.trees = 1000,
mtry      = floor(sqrt(ncol(x_train_top))),
min.node.size = best_par$min.node.size,
splitrule = best_par$splitrule,
importance = "permutation",
probability = TRUE,
respect.unordered.factors = "order",
class.weights = class_weights
)
rf_pred_top  <- predict(rf_top, data = x_test_top)
prob_mat_top <- rf_pred_top$predictions
prob_pos_top <- prob_mat_top[, positive_level]
ev_top <- evaluate_binary(y_test, prob_pos_top, positive_level)
list(
glm_fit     = glm_fit,
rf_full     = rf_full,
rf_top      = rf_top,
imp_full    = imp_full,
top_feats   = top_feats,
ev_glm      = ev_glm,
ev_full     = ev_full,
ev_top      = ev_top,
tune_grid   = tune_grid,
x_train_top = x_train_top,
x_test_top  = x_test_top
)
}
############################################################
## 5. 构建可复用的模型对象（给 Shiny & R 包）
############################################################
make_heart_model_object <- function(fits, preproc) {
list(
model_type      = "rf_top10",
rf_model        = fits$rf_top,
top_features    = fits$top_feats,
preproc         = preproc,
positive_level  = preproc$positive_level,
negative_level  = preproc$negative_level,
best_threshold  = fits$ev_top$best_threshold
)
}
############################################################
## 6. 预测辅助函数：将来 R 包可以直接复用
############################################################
# 6.1 新数据预处理：按训练时的规则来
preprocess_new_heart <- function(new_data, preproc, add_features = TRUE) {
df <- as.data.frame(new_data)
if (add_features) {
required_cols <- c("Age","RestingBP","Cholesterol")
if (!all(required_cols %in% names(df))) {
stop("new_data 缺少必要列: ",
paste(setdiff(required_cols, names(df)), collapse = ", "))
}
df <- add_heart_features(df)
}
# 数值列
for (cn in intersect(preproc$num_cols, names(df))) {
df[[cn]] <- as.numeric(df[[cn]])
med <- preproc$num_medians[[cn]]
df[[cn]][is.na(df[[cn]])] <- med
}
# 因子列
for (cn in intersect(preproc$fac_cols, names(df))) {
lev_train <- preproc$fac_levels[[cn]]
df[[cn]] <- forcats::fct_explicit_na(as.factor(df[[cn]]), na_level = "Unknown")
df[[cn]] <- factor(df[[cn]], levels = lev_train)
df[[cn]] <- forcats::fct_explicit_na(df[[cn]], na_level = "Unknown")
}
# 去掉训练中删掉的近零方差特征
if (length(preproc$nzv_cols) > 0) {
keep_cols <- setdiff(names(df), preproc$nzv_cols)
df <- df[, keep_cols, drop = FALSE]
}
df
}
# 6.2 最终统一预测接口（分类任务）
# type = "class" 返回 Presence/Absence
# type = "prob"  返回预测为 Presence 的概率
predict_heart_rf_top10 <- function(model_object, new_data,
type = c("class","prob")) {
type <- match.arg(type)
preproc      <- model_object$preproc
top_features <- model_object$top_features
df_proc <- preprocess_new_heart(new_data, preproc, add_features = TRUE)
missing_feats <- setdiff(top_features, names(df_proc))
if (length(missing_feats) > 0) {
stop("预测时缺少特征: ", paste(missing_feats, collapse = ", "))
}
x_new_top <- df_proc[, top_features, drop = FALSE]
pred      <- predict(model_object$rf_model, data = x_new_top)
prob_pos  <- pred$predictions[, model_object$positive_level]
if (type == "prob") {
return(prob_pos)
}
thr <- model_object$best_threshold
pred_class <- ifelse(prob_pos >= thr,
model_object$positive_level,
model_object$negative_level)
factor(pred_class,
levels = c(model_object$negative_level, model_object$positive_level))
}
############################################################
## 7. 主流程：训练 + 画图 + SHAP + 保存 RDS
##    （脚本直接运行时会执行这部分）
############################################################
# 7.1 预处理 & 训练
dp    <- data_process_heart(data_file, p_train = 0.7, seed = 215)
fits  <- fit_heart_models(dp, seed = 215)
preproc <- dp$preproc
ev_glm  <- fits$ev_glm
ev_full <- fits$ev_full
ev_top  <- fits$ev_top
# 7.2 性能对比表（写报告时很好用）
model_compare_df <- tibble::tibble(
Model   = c("Logistic", "Full_RF", "Top10_RF"),
Accuracy = c(ev_glm$accuracy, ev_full$accuracy, ev_top$accuracy),
F1       = c(ev_glm$F1,       ev_full$F1,       ev_top$F1),
AUROC    = c(ev_glm$auroc,    ev_full$auroc,    ev_top$auroc),
AUPRC    = c(ev_glm$auprc,    ev_full$auprc,    ev_top$auprc)
)
print(model_compare_df)
# 7.3 ROC / PR 曲线（3 个模型都有：可放 Results）
# ROC – Logistic
ggroc(ev_glm$roc_obj, size = 1.1, colour = pal_models["Logistic"]) +
geom_abline(slope = 1, intercept = 0,
linetype = 2, colour = "grey70", size = 0.5) +
coord_equal() +
scale_x_continuous(limits = c(0, 1), expand = c(0, 0)) +
scale_y_continuous(limits = c(0, 1), expand = c(0, 0)) +
labs(
title    = "ROC – Logistic regression (baseline)",
subtitle = paste0("AUROC = ", round(ev_glm$auroc, 3),
", best thr = ", round(ev_glm$best_threshold, 2)),
x = "False positive rate (1 − specificity)",
y = "True positive rate (sensitivity)"
) +
theme_bio215()
# PR – Logistic
ggplot(ev_glm$pr_df, aes(x = Recall, y = Precision)) +
geom_line(size = 1.1, colour = pal_models["Logistic"]) +
scale_x_continuous(limits = c(0, 1), expand = c(0, 0)) +
scale_y_continuous(limits = c(0, 1), expand = c(0, 0)) +
labs(
title    = "Precision–Recall – Logistic regression (baseline)",
subtitle = paste0("AUPRC = ", round(ev_glm$auprc, 3)),
x = "Recall (sensitivity)",
y = "Precision (PPV)"
) +
theme_bio215()
# ROC – Full-feature RF
ggroc(ev_full$roc_obj, size = 1.1, colour = pal_models["Full_RF"]) +
geom_abline(slope = 1, intercept = 0,
linetype = 2, colour = "grey70", size = 0.5) +
coord_equal() +
scale_x_continuous(limits = c(0, 1), expand = c(0, 0)) +
scale_y_continuous(limits = c(0, 1), expand = c(0, 0)) +
labs(
title    = "ROC – Full-feature Random Forest",
subtitle = paste0("AUROC = ", round(ev_full$auroc, 3),
", best thr = ", round(ev_full$best_threshold, 2)),
x = "False positive rate",
y = "True positive rate"
) +
theme_bio215()
# PR – Full-feature RF
ggplot(ev_full$pr_df, aes(x = Recall, y = Precision)) +
geom_line(size = 1.1, colour = pal_models["Full_RF"]) +
scale_x_continuous(limits = c(0, 1), expand = c(0, 0)) +
scale_y_continuous(limits = c(0, 1), expand = c(0, 0)) +
labs(
title    = "Precision–Recall – Full-feature Random Forest",
subtitle = paste0("AUPRC = ", round(ev_full$auprc, 3)),
x = "Recall",
y = "Precision"
) +
theme_bio215()
# ROC – Top-10 RF
ggroc(ev_top$roc_obj, size = 1.1, colour = pal_models["Top10_RF"]) +
geom_abline(slope = 1, intercept = 0,
linetype = 2, colour = "grey70", size = 0.5) +
coord_equal() +
scale_x_continuous(limits = c(0, 1), expand = c(0, 0)) +
scale_y_continuous(limits = c(0, 1), expand = c(0, 0)) +
labs(
title    = "ROC – Top-10 feature Random Forest",
subtitle = paste0("AUROC = ", round(ev_top$auroc, 3),
", best thr = ", round(ev_top$best_threshold, 2)),
x = "False positive rate",
y = "True positive rate"
) +
theme_bio215()
# PR – Top-10 RF
ggplot(ev_top$pr_df, aes(x = Recall, y = Precision)) +
geom_line(size = 1.1, colour = pal_models["Top10_RF"]) +
scale_x_continuous(limits = c(0, 1), expand = c(0, 0)) +
scale_y_continuous(limits = c(0, 1), expand = c(0, 0)) +
labs(
title    = "Precision–Recall – Top-10 feature Random Forest",
subtitle = paste0("AUPRC = ", round(ev_top$auprc, 3)),
x = "Recall",
y = "Precision"
) +
theme_bio215()
# 7.4 三个模型性能对比条形图
plot_df <- tidyr::pivot_longer(
model_compare_df,
cols = c("Accuracy", "F1", "AUROC", "AUPRC"),
names_to = "Metric",
values_to = "Value"
)
plot_df$Metric <- factor(
plot_df$Metric,
levels = c("Accuracy", "F1", "AUROC", "AUPRC")
)
ggplot(plot_df, aes(x = Metric, y = Value, fill = Model)) +
geom_col(position = position_dodge(width = 0.7), width = 0.6) +
geom_text(
aes(label = round(Value, 3)),
position = position_dodge(width = 0.7),
vjust = -0.4, size = 3.3
) +
scale_fill_manual(values = pal_models) +
scale_y_continuous(
limits = c(0, 1),
expand = expansion(mult = c(0, 0.05))
) +
labs(
title = "Test-set performance of three models",
x = NULL,
y = "Score"
) +
theme_bio215() +
theme(
axis.text.x = element_text(angle = 15, hjust = 1)
)
# 7.5 特征重要性（Top-10 RF）
imp_best <- vip::vi(fits$rf_top) %>%
arrange(desc(Importance)) %>%
slice_head(n = 20) %>%
mutate(
Variable = forcats::fct_reorder(Variable, Importance)
)
ggplot(imp_best, aes(x = Variable, y = Importance, fill = Importance)) +
geom_col(width = 0.6) +
coord_flip() +
scale_fill_gradient(low = "#9ecae1", high = "#08519c") +
labs(
title = "Top 20 feature importance (Top-10 RF model)",
x = NULL,
y = "Permutation importance"
) +
theme_bio215() +
theme(
axis.text.y = element_text(size = 11)
)
# 7.6 SHAP 分析（解释 Top-10 RF 模型）
shap_X <- as.data.frame(fits$x_test_top) %>% tidyr::drop_na()
set.seed(215)
if (nrow(shap_X) > 300) {
shap_X <- shap_X[sample.int(nrow(shap_X), 300), , drop = FALSE]
}
shap_mat <- fastshap::explain(
object = fits$rf_top,
X      = shap_X,
nsim   = 100,
pred_wrapper = function(object, newdata) {
predict(object, data = newdata)$predictions[, preproc$positive_level]
}
)
sv <- shapviz(shap_mat, X = shap_X)
# SHAP beeswarm（全局效果）
sv_importance(sv, kind = "beeswarm", max_display = min(10, ncol(shap_X)))
# dependence plot：例如 Age 和 Oldpeak
if ("Age" %in% colnames(shap_X)) {
sv_dependence(sv, "Age")
}
if ("Oldpeak" %in% colnames(shap_X)) {
sv_dependence(sv, "Oldpeak")
}
# 7.7 保存最终模型对象
heart_model_object <- make_heart_model_object(fits, preproc)
saveRDS(heart_model_object, file = model_rds)
message("✅ 模型已保存到: ", model_rds)
############################################################
## 使用示例（将来在 Shiny / R 包里）：
##
## mdl <- readRDS("heart_rf_top10_model.rds")
## new_patients <- data.frame(
##   Age = c(54, 63),
##   Sex = c("M","F"),
##   ChestPainType = c("ATA","NAP"),
##   RestingBP = c(140, 120),
##   Cholesterol = c(289, 250),
##   FastingBS = c(0, 1),
##   RestingECG = c("Normal","ST"),
##   MaxHR = c(150, 132),
##   ExerciseAngina = c("N","Y"),
##   Oldpeak = c(1.5, 2.3),
##   ST_Slope = c("Up","Flat")
## )
##
## predict_heart_rf_top10(mdl, new_patients, type = "class")
## predict_heart_rf_top10(mdl, new_patients, type = "prob")
############################################################
