axis.title    = element_text(face = "bold"),
axis.text     = element_text(color = "black"),
panel.grid.minor   = element_blank(),
panel.grid.major.x = element_blank(),
legend.position    = "right",
legend.title       = element_blank()
)
}
pal_models <- c(
Logistic = "#1f77b4",  # 蓝
Full_RF  = "#2ca02c",  # 绿
Top10_RF = "#d62728"   # 红
)
## ------------------ 0c. 配置：文件名等 ---------------------
data_file <- "heart 3.csv"                # ★ 你的 CSV
model_rds <- "heart_rf_top10_model.rds"   # ★ 模型保存位置
############################################################
## 1. 特征工程函数：方便训练 & 预测阶段复用
############################################################
add_heart_features <- function(df) {
# 要求 df 至少包含：Age, RestingBP, Cholesterol
df %>%
mutate(
age_decade     = floor(as.numeric(Age) / 10) * 10,
high_bp_flag   = if_else(as.numeric(RestingBP) >= 140, 1, 0),
high_chol_flag = if_else(as.numeric(Cholesterol) >= 240, 1, 0)
)
}
############################################################
## 2. 数据预处理：读取 CSV, 清洗, 特征工程, train/test 划分
############################################################
data_process_heart <- function(file, p_train = 0.7, seed = 215) {
set.seed(seed)
# 读取原始数据
heart_raw <- readr::read_csv(file, show_col_types = FALSE)
message("原始数据维度: ", nrow(heart_raw), " 行, ", ncol(heart_raw), " 列")
print(names(heart_raw))
heart <- heart_raw
## ---- 1) 确保数值列是 numeric ----
num_to_numeric <- c("Age","RestingBP","Cholesterol","MaxHR","Oldpeak")
for (cn in intersect(num_to_numeric, names(heart))) {
heart[[cn]] <- as.numeric(heart[[cn]])
}
## ---- 2) 统一 HeartDisease 为 Absence / Presence ----
if (is.numeric(heart$HeartDisease)) {
heart$HeartDisease <- ifelse(heart$HeartDisease == 1, "Presence", "Absence")
} else {
hd_char <- as.character(heart$HeartDisease)
if (all(na.omit(hd_char) %in% c("0","1"))) {
heart$HeartDisease <- ifelse(hd_char == "1", "Presence", "Absence")
} else if (all(na.omit(hd_char) %in% c("No","Yes"))) {
heart$HeartDisease <- ifelse(hd_char == "Yes", "Presence", "Absence")
} else {
heart$HeartDisease <- hd_char
}
}
heart$HeartDisease <- factor(heart$HeartDisease,
levels = c("Absence","Presence"))
## ---- 3) 因子变量 + 特征工程 ----
heart <- heart %>%
mutate(
Sex            = factor(Sex),
ChestPainType  = factor(ChestPainType),
FastingBS      = factor(FastingBS),
RestingECG     = factor(RestingECG),
ExerciseAngina = factor(ExerciseAngina),
ST_Slope       = factor(ST_Slope)
) %>%
add_heart_features() %>%
mutate(
age_decade     = factor(age_decade),
high_bp_flag   = factor(high_bp_flag),
high_chol_flag = factor(high_chol_flag)
)
## ---- 4) train / test 分层抽样 ----
idx <- caret::createDataPartition(heart$HeartDisease,
p = p_train, list = FALSE)
train_dat <- heart[idx, ]
test_dat  <- heart[-idx, ]
x_train <- train_dat %>% select(-HeartDisease)
x_test  <- test_dat  %>% select(-HeartDisease)
y_train <- train_dat$HeartDisease
y_test  <- test_dat$HeartDisease
## ---- 5) 缺失值处理 & 记录 preproc 信息 ----
num_cols <- names(x_train)[sapply(x_train, is.numeric)]
fac_cols <- names(x_train)[sapply(x_train, is.factor)]
# 数值列：用 train 中位数填补
num_medians <- vapply(num_cols, function(cn) {
median(x_train[[cn]], na.rm = TRUE)
}, numeric(1))
for (cn in num_cols) {
med <- num_medians[[cn]]
x_train[[cn]][is.na(x_train[[cn]])] <- med
x_test[[cn]][is.na(x_test[[cn]])]   <- med
}
# 因子列：NA -> "Unknown"，并对齐 levels
fac_levels <- list()
for (cn in fac_cols) {
x_train[[cn]] <- forcats::fct_explicit_na(x_train[[cn]], na_level = "Unknown")
x_test[[cn]]  <- forcats::fct_explicit_na(x_test[[cn]],  na_level = "Unknown")
x_test[[cn]]  <- factor(x_test[[cn]], levels = levels(x_train[[cn]]))
fac_levels[[cn]] <- levels(x_train[[cn]])
}
# 近零方差特征删除，记录被删掉的列名
nzv_idx <- nearZeroVar(x_train)
if (length(nzv_idx) > 0) {
nzv_cols <- colnames(x_train)[nzv_idx]
x_train  <- x_train[, -nzv_idx, drop = FALSE]
x_test   <- x_test[,  -nzv_idx, drop = FALSE]
} else {
nzv_cols <- character(0)
}
train_dat_rf  <- data.frame(HeartDisease = y_train, x_train)
train_dat_glm <- train_dat_rf
positive_level <- "Presence"
negative_level <- setdiff(levels(y_train), positive_level)
preproc <- list(
num_cols       = num_cols,
num_medians    = num_medians,
fac_cols       = fac_cols,
fac_levels     = fac_levels,
nzv_cols       = nzv_cols,
positive_level = positive_level,
negative_level = negative_level
)
list(
heart_raw      = heart_raw,
heart_clean    = heart,
x_train        = x_train,
x_test         = x_test,
y_train        = y_train,
y_test         = y_test,
train_dat_rf   = train_dat_rf,
train_dat_glm  = train_dat_glm,
preproc        = preproc
)
}
############################################################
## 3. 统一二分类评估函数：Accuracy / F1 / AUROC / AUPRC
############################################################
evaluate_binary <- function(y_true, prob_pos, positive_level = "Presence") {
y_bin <- ifelse(y_true == positive_level, 1, 0)
# ROC / AUROC
roc_obj <- pROC::roc(response = y_bin, predictor = prob_pos, quiet = TRUE)
auroc   <- as.numeric(pROC::auc(roc_obj))
# PR / AUPRC
pr_obj <- PRROC::pr.curve(
scores.class0 = prob_pos[y_bin == 1],  # 正类
scores.class1 = prob_pos[y_bin == 0],  # 负类
curve = TRUE
)
auprc <- pr_obj$auc.integral
pr_df <- as.data.frame(pr_obj$curve)
colnames(pr_df) <- c("Recall","Precision","Threshold")
# PR 曲线上的点计算 F1，选 F1 最大的阈值
pr_df$F1 <- 2 * pr_df$Precision * pr_df$Recall /
(pr_df$Precision + pr_df$Recall)
best_row <- pr_df[which.max(pr_df$F1), ]
best_thr <- best_row$Threshold
negative_level <- setdiff(levels(y_true), positive_level)
pred_class <- factor(
ifelse(prob_pos >= best_thr, positive_level, negative_level),
levels = levels(y_true)
)
cm <- caret::confusionMatrix(pred_class, y_true, positive = positive_level)
accuracy <- cm$overall["Accuracy"]
precision <- cm$byClass["Pos Pred Value"]
recall    <- cm$byClass["Sensitivity"]
F1        <- 2 * precision * recall / (precision + recall)
list(
auroc          = auroc,
auprc          = auprc,
accuracy       = as.numeric(accuracy),
F1             = as.numeric(F1),
best_threshold = best_thr,
roc_obj        = roc_obj,
pr_df          = pr_df,
cm             = cm,
pred_class     = pred_class
)
}
############################################################
## 4. 训练所有模型：Logistic + Full RF + Top-10 RF
############################################################
fit_heart_models <- function(dp, seed = 215) {
set.seed(seed)
x_train        <- dp$x_train
x_test         <- dp$x_test
y_train        <- dp$y_train
y_test         <- dp$y_test
train_dat_rf   <- dp$train_dat_rf
train_dat_glm  <- dp$train_dat_glm
preproc        <- dp$preproc
positive_level <- preproc$positive_level
## ---- 4.1 Logistic baseline ----
glm_fit <- glm(
HeartDisease ~ .,
data   = train_dat_glm,
family = binomial()
)
prob_pos_glm <- predict(glm_fit, newdata = x_test, type = "response")
ev_glm <- evaluate_binary(y_test, prob_pos_glm, positive_level)
## ---- 4.2 RF 调参（基于 OOB-AUROC） ----
class_counts  <- table(y_train)
class_weights <- as.numeric(mean(class_counts) / class_counts)
names(class_weights) <- names(class_counts)
p <- ncol(x_train)
mtry_candidates      <- unique(pmax(1, c(floor(sqrt(p)), floor(p/3), floor(p/2))))
min_node_candidates  <- c(5, 10, 20)
splitrule_candidates <- c("gini", "extratrees")
tune_grid <- expand.grid(
mtry          = mtry_candidates,
min.node.size = min_node_candidates,
splitrule     = splitrule_candidates
)
tune_grid$oob_auc <- NA_real_
set.seed(seed)
for (i in seq_len(nrow(tune_grid))) {
cat("Fitting RF", i, "of", nrow(tune_grid), "\n")
fit_tmp <- ranger(
dependent.variable.name = "HeartDisease",
data      = train_dat_rf,
num.trees = 400,
mtry      = tune_grid$mtry[i],
min.node.size = tune_grid$min.node.size[i],
splitrule = tune_grid$splitrule[i],
importance = "impurity",
probability = TRUE,
respect.unordered.factors = "order",
class.weights = class_weights
)
oob_prob <- fit_tmp$predictions[, positive_level]
y_oob    <- y_train
roc_oob <- pROC::roc(
response  = ifelse(y_oob == positive_level, 1, 0),
predictor = oob_prob,
quiet     = TRUE
)
tune_grid$oob_auc[i] <- as.numeric(pROC::auc(roc_oob))
}
best_par <- tune_grid[which.max(tune_grid$oob_auc), ]
print(best_par)
## ---- 4.3 最终 RF（全特征） ----
set.seed(seed)
rf_full <- ranger(
dependent.variable.name = "HeartDisease",
data      = train_dat_rf,
num.trees = 1000,
mtry      = best_par$mtry,
min.node.size = best_par$min.node.size,
splitrule = best_par$splitrule,
importance = "permutation",
probability = TRUE,
respect.unordered.factors = "order",
class.weights = class_weights
)
rf_pred_full  <- predict(rf_full, data = x_test)
prob_mat_full <- rf_pred_full$predictions
prob_pos_full <- prob_mat_full[, positive_level]
ev_full <- evaluate_binary(y_test, prob_pos_full, positive_level)
## ---- 4.4 Top-10 特征 RF ----
imp_full <- vip::vi(rf_full) %>%
arrange(desc(Importance))
print(imp_full)
top_feats <- imp_full$Variable[1:min(10, nrow(imp_full))]
message("Top-10 特征: ", paste(top_feats, collapse = ", "))
x_train_top <- x_train[, top_feats, drop = FALSE]
x_test_top  <- x_test[,  top_feats,  drop = FALSE]
train_dat_top <- data.frame(HeartDisease = y_train, x_train_top)
set.seed(seed)
rf_top <- ranger(
dependent.variable.name = "HeartDisease",
data      = train_dat_top,
num.trees = 1000,
mtry      = floor(sqrt(ncol(x_train_top))),
min.node.size = best_par$min.node.size,
splitrule = best_par$splitrule,
importance = "permutation",
probability = TRUE,
respect.unordered.factors = "order",
class.weights = class_weights
)
rf_pred_top  <- predict(rf_top, data = x_test_top)
prob_mat_top <- rf_pred_top$predictions
prob_pos_top <- prob_mat_top[, positive_level]
ev_top <- evaluate_binary(y_test, prob_pos_top, positive_level)
list(
glm_fit     = glm_fit,
rf_full     = rf_full,
rf_top      = rf_top,
imp_full    = imp_full,
top_feats   = top_feats,
ev_glm      = ev_glm,
ev_full     = ev_full,
ev_top      = ev_top,
tune_grid   = tune_grid,
x_train_top = x_train_top,
x_test_top  = x_test_top
)
}
############################################################
## 5. 构建可复用的模型对象（给 Shiny & R 包）
############################################################
make_heart_model_object <- function(fits, preproc) {
list(
model_type      = "rf_top10",
rf_model        = fits$rf_top,
top_features    = fits$top_feats,
preproc         = preproc,
positive_level  = preproc$positive_level,
negative_level  = preproc$negative_level,
best_threshold  = fits$ev_top$best_threshold
)
}
############################################################
## 6. 预测辅助函数：将来 R 包可以直接复用
############################################################
# 6.1 新数据预处理：按训练时的规则来
preprocess_new_heart <- function(new_data, preproc, add_features = TRUE) {
df <- as.data.frame(new_data)
if (add_features) {
required_cols <- c("Age","RestingBP","Cholesterol")
if (!all(required_cols %in% names(df))) {
stop("new_data 缺少必要列: ",
paste(setdiff(required_cols, names(df)), collapse = ", "))
}
df <- add_heart_features(df)
}
# 数值列
for (cn in intersect(preproc$num_cols, names(df))) {
df[[cn]] <- as.numeric(df[[cn]])
med <- preproc$num_medians[[cn]]
df[[cn]][is.na(df[[cn]])] <- med
}
# 因子列
for (cn in intersect(preproc$fac_cols, names(df))) {
lev_train <- preproc$fac_levels[[cn]]
df[[cn]] <- forcats::fct_explicit_na(as.factor(df[[cn]]), na_level = "Unknown")
df[[cn]] <- factor(df[[cn]], levels = lev_train)
df[[cn]] <- forcats::fct_explicit_na(df[[cn]], na_level = "Unknown")
}
# 去掉训练中删掉的近零方差特征
if (length(preproc$nzv_cols) > 0) {
keep_cols <- setdiff(names(df), preproc$nzv_cols)
df <- df[, keep_cols, drop = FALSE]
}
df
}
# 6.2 最终统一预测接口（分类任务）
# type = "class" 返回 Presence/Absence
# type = "prob"  返回预测为 Presence 的概率
predict_heart_rf_top10 <- function(model_object, new_data,
type = c("class","prob")) {
type <- match.arg(type)
preproc      <- model_object$preproc
top_features <- model_object$top_features
df_proc <- preprocess_new_heart(new_data, preproc, add_features = TRUE)
missing_feats <- setdiff(top_features, names(df_proc))
if (length(missing_feats) > 0) {
stop("预测时缺少特征: ", paste(missing_feats, collapse = ", "))
}
x_new_top <- df_proc[, top_features, drop = FALSE]
pred      <- predict(model_object$rf_model, data = x_new_top)
prob_pos  <- pred$predictions[, model_object$positive_level]
if (type == "prob") {
return(prob_pos)
}
thr <- model_object$best_threshold
pred_class <- ifelse(prob_pos >= thr,
model_object$positive_level,
model_object$negative_level)
factor(pred_class,
levels = c(model_object$negative_level, model_object$positive_level))
}
############################################################
## 7. 主流程：训练 + 画图 + SHAP + 保存 RDS
##    （脚本直接运行时会执行这部分）
############################################################
# 7.1 预处理 & 训练
dp    <- data_process_heart(data_file, p_train = 0.7, seed = 215)
devtools::document()
devtools::document() # Generate/update documentation and NAMESPACE
devtools::load_all() # Reload the package into your current R session
## 假设你已经在包工程里执行过：
## devtools::document()
## devtools::load_all()   # 开发阶段
## 或者已经 install 并 library(yourPackageName)
# library(heartBio215)  # 用你的包名替换
# 1. 构造一个 Kaggle 风格列名的新病人数据
new_patients_kaggle <- data.frame(
Age               = c(54, 63, 45),
Sex               = c("M", "F", "M"),
BP                = c(140, 120, 130),
Cholesterol       = c(289, 250, 180),
`Chest pain type` = c("ATA", "NAP", "ASY"),
`Max HR`          = c(150, 132, 160),
`Exercise angina` = c("N", "Y", "N"),
`ST depression`   = c(1.5, 2.3, 0.5)
)
# 2. 返回预测类别
pred_class <- predict_heart_bio215(new_patients_kaggle, type = "class")
library(ranger)
## 假设你已经在包工程里执行过：
## devtools::document()
## devtools::load_all()   # 开发阶段
## 或者已经 install 并 library(yourPackageName)
# library(heartBio215)  # 用你的包名替换
# 1. 构造一个 Kaggle 风格列名的新病人数据
new_patients_kaggle <- data.frame(
Age               = c(54, 63, 45),
Sex               = c("M", "F", "M"),
BP                = c(140, 120, 130),
Cholesterol       = c(289, 250, 180),
`Chest pain type` = c("ATA", "NAP", "ASY"),
`Max HR`          = c(150, 132, 160),
`Exercise angina` = c("N", "Y", "N"),
`ST depression`   = c(1.5, 2.3, 0.5)
)
# 2. 返回预测类别
pred_class <- predict_heart_bio215(new_patients_kaggle, type = "class")
devtools::document()  # 生成/更新文档和 NAMESPACE
devtools::load_all()  # 将这个包重新加载到当前 R 会话中
# 1. 重新生成 NAMESPACE 和文档
devtools::document()
# 2. 开发阶段加载包
devtools::load_all()
# 3. 简单测试一下
new_patients <- data.frame(
Age               = c(54, 63),
Sex               = c("M", "F"),
BP                = c(140, 120),
Cholesterol       = c(289, 250),
`Chest pain type` = c("ATA", "NAP"),
`Max HR`          = c(150, 132),
`Exercise angina` = c("N", "Y"),
`ST depression`   = c(1.5, 2.3)
)
predict_heart_bio215(new_patients)
predict_heart_bio215(new_patients, type = "prob")
## 假设你已经在包工程里执行过：
## devtools::document()
## devtools::load_all()   # 开发阶段
## 或者已经 install 并 library(yourPackageName)
# library(heartBio215)  # 用你的包名替换
# 1. 构造一个 Kaggle 风格列名的新病人数据
new_patients_kaggle <- data.frame(
Age               = c(54, 63, 45),
Sex               = c("M", "F", "M"),
BP                = c(140, 120, 130),
Cholesterol       = c(289, 250, 180),
`Chest pain type` = c("ATA", "NAP", "ASY"),
`Max HR`          = c(150, 132, 160),
`Exercise angina` = c("N", "Y", "N"),
`ST depression`   = c(1.5, 2.3, 0.5)
)
# 2. 返回预测类别
pred_class <- predict_heart_bio215(new_patients_kaggle, type = "class")
print(pred_class)
# 3. 返回 Presence 的概率
pred_prob <- predict_heart_bio215(new_patients_kaggle, type = "prob")
print(pred_prob)
# 4. 把结果合并回表格，方便写报告/截图
result_table <- cbind(
new_patients_kaggle,
PredictedClass = pred_class,
ProbPresence   = round(pred_prob, 3)
)
print(result_table)
# 5. 也测试一次“干净列名”的情况
new_patients_clean <- data.frame(
Age            = c(50, 70),
Sex            = c("M", "F"),
BP             = c(135, 160),
Cholesterol    = c(210, 300),
ChestPainType  = c("ATA", "TA"),
MaxHR          = c(155, 120),
ExerciseAngina = c("N", "Y"),
ST_depression  = c(0.8, 2.0)
)
predict_heart_bio215(new_patients_clean, type = "class")
predict_heart_bio215(new_patients_clean, type = "prob")
devtools::document()
devtools::document()
devtools::document()
devtools::load_all()
devtools::document()
devtools::load_all()
pkgload::dev_help('predict_heart_single')
devtools::document()
devtools::load_all()
devtools::document()
devtools::load_all()
?predict_heart_bio215
new_patients <- data.frame(
Age               = c(54, 63),
Sex               = c("M", "F"),
BP                = c(140, 120),
Cholesterol       = c(289, 250),
`Chest pain type` = c("ATA", "NAP"),
`Max HR`          = c(150, 132),
`Exercise angina` = c("N", "Y"),
`ST depression`   = c(1.5, 2.3)
)
# Predicted classes (Absence/Presence):
predict_heart_bio215(new_patients)
# Predicted probabilities of Presence:
predict_heart_bio215(new_patients, type = "prob")
## End(Not run)
library(shiny); runApp('~/Desktop/bio215/bio215 final project/heart3_shinny.R')
rsconnect::deployApp()
devtools::document()  # 更新 man/ 目录里的 Rd 文档
devtools::check()     # 可选，检查包有没有 ERROR/WARNING
